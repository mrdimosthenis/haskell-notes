# Δέκα πράγματα που πρέπει να γνωρίζεις για το συντακτικό της Haskell

Η εκμάθηση μίας καινούργιας γλώσσας προγραμματισμού περιλαμβάνει το συντακτικό, την σημασιολογία και τα ιδιώματα. Το συντακτικό μπορεί να φανερώσει πολλά για την φιλοσοφία της γλώσσας αλλά, χωρίς το γενικό πλαίσιο, είναι δύσκολο και βαρετό. Από την άλλη, θα ήθελες να καταπιαστείς με το συντακτικό όσο γίνεται πιο νωρίς, για να μπορέσεις να δεις-διαβάσεις απλά προγράμματα και να δοκιμάσεις να τα τροποποιήσεις.

Αυτή είναι λοιπόν μία μικρή εισαγωγή στο συντακτικό της Haskell, απαλαγμένη από επίσιμους ορισμούς, που προσεγγίζει την φιλοσοφία της γλώσσας και προσπαθεί να μην καταντίσει βαρετή. Αν δεν είσαι ήδη επαγγελματίας της Haskell, δεν πρόκειται να τα καταλάβεις όλα κατά την πρώτη ανάγνωση. Είναι πιθανό να θελήσεις να επιστρέψεις σε αυτά καθώς θα σημειώνεις πρόοδο στην κατανόηση της Haskell. (Αν είσαι επαγγελματίας της Haskell, ίσως δυσανασχετίσεις με μερικές νοητικές παρακάμψεις που έκανα χάριν απλότητας.)

## Πίνακας Περιεχομένων

1. H Haskell είναι Λιτή
2. Η Κλήση Συνάρτησης είναι Λιτή
3. Ο Ορισμός Συνάρτησης είναι Λιτός
4. Το Currying είναι Cool (και Λιτό)
5. Ό,τι δεν είναι Δήλωση είναι Έκφραση
6. Δεν υπάρχουν Βρόχοι
7. Η Εφαρμογή των Συναρτήσεων έχει Προτεραιότητα απέναντι στους Τελεστές
8. Οι Τύποι Δεδομένων είναι Αλγεβρικοί και γίνεται παντού Αντιπαραβολή Μοτίβων
9. Δεν υπάρχει Σειρά
10. Υπάρχει Σειρά μέσα στο Do

## 1. Η Haskell είναι Λιτή

Ο πλεονασμός είναι σπάνιο φαινόμενο στην Haskell, επομένως σχεδόν όλα,
συμπεριλαμβανομένων των κενών (whitespace), έχουν νόημα.
Το θετικό είναι ότι, μόλις το συνηθίσεις, θα μπορείς να δεις την λογική ενός
προγράμματος με μία ματιά. Σε μία φλύαρη γλώσσα δεν σπαταλάς μόνο πολύτιμο χρόνο
για να πληκτρολογήσεις, αποδυναμώνεις επίσης την δομή και το νόημα του
προγράμματος. Ένα κομμάτι κώδικα Haskell που γεμίζει ολόκληρη την οθόνη, θα
γέμιζε αρκετές οθόνες στην Java. Για έναν Haskell developer, το να μελετήσει ένα
πρόγραμμα που είναι γραμμένο σε Java ή στην C++ μοιάζει με το να κοιτάζει σε
μικροσκόπιο: παρατηρείς πολλές λεπτομέρειες αλλά χάνεις την γενική εικόνα.

Ένα από τα στοιχεία που φαίνεται να είναι απαραίτητο στις υπόλοιπες γλώσσες
είναι οι ειδικοί χαρακτήρες για τον διαχωρισμό των statements (π.χ. το
ερωτηματικό `;`) και οι οριοθετήσεις (π.χ. τα άγκιστρα `{}`). Κάθε
προγραμματιστής που σέβεται τον εαυτό του χρησιμοποιεί την μορφοποίηση για να
κάνει τον κώδικά του πιο αναγνώσιμο, αλλά ο compiler δεν επηρεάζεται από την
μορφοποίηση. Η Haskell κάνει (σχεδόν) το αντίθετο. Αναγνωρίζει τις οριοθετήσεις (blocks) από τις **εσοχές** (με space, όχι tab) που χωρίζονται από τις **αλλαγές
γραμμών**.

Μέρος αυτής της λιτής φιλοσοφίας είναι το ότι στην Haskell δεν απαιτείται η
σημείωση των τύπων -- αν και ο έμπειρος Haskeller τις παρέχει χάριν σαφήνειας --
επομένως τα λάθη που σχετίζονται με τους τύπους φαίνονται στους αμύητους ως
αινίγματα. Για παράδειγμα, αν ορίσεις μία συνάρτηση `f` που προσθέτει δύο
αριθμούς και στην συνέχεια την καλέσεις για δύο strings, ο compiler δεν θα
παραπονεθεί για λάθος στις παραμέτρους, θα παραπονεθεί για το ότι τα strings δεν
υποστηρίζουν τον τελεστή της πρόσθεσης. Και θα διατυπώσει αυτό το παράπονο με
όχι και τόσο ξεκάθαρο τρόπο:

```
No instance for (Num [Char]) arising from a use of `f'
    Possible fix: add an instance declaration for (Num [Char])
```

Επίσης, παίζει ρόλο το αν χρησιμοποιηθούν πεζοί ή κεφαλαίοι χαρακτήρες.
Οτιδήποτε ξεκινά με **κεφαλαίο γράμμα** είναι είτε συγκεκριμένος τύπος, είτε
_data constructor_. Τα ονόματα που ξεκινούν με πεζό χαρακτήρα είναι δεσμευμένα
για τις συναρτήσεις και τις μεταβλητές, συμπεριλαμβανομένων των _type variables_.

Το αρνητικό της λιτότητας είναι ότι η έλλειψη πλεονασμού κάνει την αναφορά των
λαθών δυσκολότερη. Ο compiler δεν γνωρίζει αν ξέχασες να κλείσεις μία παρένθεση
ή αν τα έκανες θάλασσα με τις εσοχές.
